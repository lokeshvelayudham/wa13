import numpy as np
import matplotlib.pyplot as plt

# Simulate data
def generate_data(p, size):
    return np.random.binomial(1, p, size)

# Assuming uniform prior for simplicity
def compute_posterior(data):
    # Likelihoods for our five hypotheses
    likelihoods = [0.1, 0.2, 0.4, 0.2, 0.1]
    posterior = [1/5 * np.power(p, data.sum()) * np.power((1-p), (len(data) - data.sum())) for p in likelihoods]
    
    # Normalize the posterior
    posterior = posterior / np.sum(posterior)
    return posterior

# Generate data for h3 and h4
data_h3 = generate_data(0.4, 100)
data_h4 = generate_data(0.2, 100)

# Compute and plot the posterior probabilities
fig, axes = plt.subplots(2, 1, figsize=(10,10))

for idx, data in enumerate([data_h3, data_h4]):
    posteriors = []
    for i in range(1, 101):
        posteriors.append(compute_posterior(data[:i]))
    axes[idx].plot(range(1, 101), [p[0] for p in posteriors], label='h1')
    axes[idx].plot(range(1, 101), [p[1] for p in posteriors], label='h2')
    axes[idx].plot(range(1, 101), [p[2] for p in posteriors], label='h3')
    axes[idx].plot(range(1, 101), [p[3] for p in posteriors], label='h4')
    axes[idx].plot(range(1, 101), [p[4] for p in posteriors], label='h5')
    axes[idx].legend()
    axes[idx].set_title(f"Data generated by {'h3' if idx == 0 else 'h4'}")
    axes[idx].set_xlabel('Number of observations in d')
    axes[idx].set_ylabel('Posterior probability of hypothesis')
plt.tight_layout()
plt.show()
